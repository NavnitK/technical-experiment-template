# ADR 1 : Encryption of Data in Transit Between Laptop Client Application and Raspberry Pi over Wi-Fi
The client application (GUI) running on a laptop communicates with software on a Raspberry Pi over Wi-Fi. The need to secure data exchanged between the laptop GUI and Raspberry Pi via Wi-Fi involves key considerations that impact the choice of encryption approach:

- Technological constraints
  - Limited resources on the Raspberry Pi
    RPi's CPU, memory, and storage limitations require efficient, lightweight encryption methods
  - Operating system compatibility
    Encryption tools and libraries must support both Linux on the Raspberry Pi and Windows for the GUI client to ensure interoperability
  - Network conditions
    Non deterministic WiFi bandwidth and latency, impose limits on communication overhead.
  - Integration complexity
    Encryption approach must integrate smoothly with existing system components and communication protocols without extensive refactoring
- Cost factors
Preference for free, open-source solutions with low development and maintenance overhead
- Project local
Despite being a local setup, the system must treat the network as potentially hostile and secure communication accordingly

## Decision
We adopt the following two tactics to secure data between the laptop and Raspberry Pi:
1. ✅ **Use TLS to Protect Data in Transit**  
   - **Supports:**  
     - Encrypts the entire communication channel, protecting all data—including metadata and message headers—while in transit  
     - Uses a proven, standardized protocol widely supported on both Windows and Linux  
     - Simplifies implementation by leveraging mature libraries like OpenSSL or mbedTLS  
     - Ensures confidentiality, integrity, and authentication of communication  
   - **Limitations:**  
     - Introduces overhead due to TLS handshake and encryption processing  
     - Requires managing certificates or keys, adding operational complexity  
     - Uses more CPU and memory on the Raspberry Pi compared to unencrypted communication  
2. ❌ **Message-Layer Security**  
   - **Supports:**  
     - Encrypts individual messages (e.g., using RSA), providing end-to-end security even if the transport layer is compromised  
     - Allows flexibility in encryption algorithms and key management schemes at the application layer  
     - Can be optimized for lightweight use on limited hardware  
   - **Limitations:**  
     - Requires custom implementation with careful design to avoid security vulnerabilities  
     - Adds development and maintenance complexity  
     - Requires secure key exchange and management at the application level  
## Rationale
| Quality Attribute   | TLS to Protect Data in Transit            | Message-Layer Security                    | Trade-off Summary                                                  |
|---------------------|-------------------------------------------|------------------------------------------|-------------------------------------------------------------------|
| **Security**        | Encrypts the entire communication channel, securing all data and metadata in transit | Encrypts only the message payload, protecting message confidentiality end-to-end | TLS secures the full transport layer; message-layer secures just the message content |
| **Performance**     | Moderate CPU and network overhead due to TLS handshake and encryption | Higher CPU load due to RSA or other encryption per message | TLS overhead is manageable; message-layer encryption can be more CPU-intensive and complex to optimize |
| **Resilience**      | Supports session resumption and stable connections | Protects message content even if transport layer is broken or terminated | TLS enhances connection stability; message-layer adds an additional security layer independent of transport |
| **Maintainability** | Uses mature libraries, reducing development effort | Requires custom development, increasing complexity | TLS reduces development and maintenance effort but requires certificate/key management; message-layer increases maintenance burden |

### Technical Skills
- The team is experienced with TLS and mature libraries (OpenSSL, mbedTLS) on Linux and Windows, facilitating efficient implementation.
- Limited experience with custom message-layer encryption and key management increases development risk and effort.
- Choosing TLS aligns with current team skills and project constraints.

### Experiments
Following experiments were conducted to support the decision based on the rationale stated above:
1. **TLS to Protect Data in Transit**  
   - Modified Raspberry Pi software and Windows GUI client to support TLS channel encryption.  
   - Integrated mbedTLS library on both sides to establish secure communication over Wi-Fi.  
   - Tested connection setup, data transfer, and handshake processes to verify confidentiality and integrity.  
   - Measured CPU and memory usage on Raspberry Pi during TLS communication to assess resource impact.
2. **Message-Layer Security**  
   - Implemented RSA encryption and decryption for sensitive message payloads on both Raspberry Pi and Windows GUI.  
   - Tested message confidentiality with and without transport layer encryption.  
   - Evaluated performance overhead caused by RSA operations on the Raspberry Pi.  
   - Assessed complexity of key management and integration with existing communication flow.

> **In summary, TLS provides robust, standardized channel encryption, securing all data during transmission. Message-layer security offers finer-grained, end-to-end message encryption but adds complexity and overhead. Given resource constraints and the goal of leveraging existing standards, TLS is chosen as the primary approach, while message-layer security is deferred.**

## Status
[ **Proposed** | Accepted | Deprecated | Superseded]

## Consequences
- **Positive:**  
  - Strong, standardized encryption protects all data in transit.  
  - Reduces development effort by using mature TLS libraries.  
  - Ensures cross-platform compatibility (Windows and Linux).  
  - Improves connection stability with built-in session management.  
  - Simplifies key management via established TLS mechanisms.

- **Negative:**  
  - Increased CPU and memory use on the Raspberry Pi.  
  - Operational complexity managing TLS certificates or keys.  
  - No end-to-end message encryption; if TLS is compromised, messages may be exposed.  
  - Metadata remains visible within the encrypted channel.  
  - Future message-layer security implementation will require additional effort.
